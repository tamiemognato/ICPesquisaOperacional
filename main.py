import os
import sys
import glob

###########################################################
################ WARNINGS AND INSTRUCTIONS ################
#IF YOU WANT TO GENERATE OUTPUTS FROM AN INSTANCE, PLACE IT ARCHIVE IN THE FOLDER 'INPUTRUN'
#IF YOU JUST WANT TO SAVE THE INSTANCE ARCHIVE, PLACE IT IN THE FOLDER 'INPUTARCHIVES'
#THE FOLLOWING PROGRAM WILL LIST EVERY ARCHIVE IN 'INPUT RUN' AND GENERATE TWO OUTPUTS FOR EACH:
#   THE FIRST ONE IT IS A COPY OF THE ARCHIVE THAT CHECKS IF THE PROGRAM IS READING CORRECTLY THE INPUTS.
#   THE SECOND ONE IS A COPY OF THE DATA OF THE INPUT ARCHIVE GENERATED BY THE DICIONARY IN WHICH THE PROGRAM FIRST COPY THE DATA FROM THE ORIGINAL ARCHIVE.
###########################################################

#### import * ou import biblioteca sem o from
#IMPORT FUNCTIONS
sys.path.append('FUNCTIONS')


from FUNCTIONS.maindic import insert_inst_dic, print_inst_from_dic, print_dic_instance

from FUNCTIONS.secdics import * #all the functions

from ALGORITHMS.ALGORITHM1 import ALGORITHM1


###########################################################

os.chdir("INPUTRUN")                                     #GRANELTM > INPUTRUN

files_inputrun = glob.glob('*.txt')                      #LISTING ALL THE .TXT FILES IN THE INPUTRUN FOLDER  ###list pensar outro nome
if len(files_inputrun) == 0:
    print("There is no valid input file to read in the INPUTRUN folder.")
else:
    for file in files_inputrun:
        #função le instancia
        #read_input(i)                                   #GENERATING IDENTICAL OUTPUTS OF THE INSTANCES.TXT  #### pensar em nome mais legivel copy #pouco útil #talvez apagar
        dic_instance = insert_inst_dic(file)             #LOADING THE INSTANCE IN A DICTIONARY
        print_inst_from_dic(dic_instance)               #GENERATING INSTANCES.TXT DATA OUTPUT OF THE RESPECTIVE DICTIONARIES
        print_dic_instance(dic_instance)
        #print(dic_instance)

        #def teste:
        #return variavel1, variavel2, variavel3

        # dic_instance, dic_ship, dic_stockpile = funcao teste

        dic_ship = fill_in_dic_ship(dic_instance)
        print_dic_ship(dic_ship)
        #print(dic_ship)

        dic_stockpile = fill_in_dic_stockpile(dic_instance)
        print_dic_stockpile(dic_stockpile)
        #print(dic_stockpile)

        dic_berth = fill_in_dic_berth(dic_instance)
        print_dic_berth(dic_berth)
        #print(dic_berth)

        dic_pad = fill_in_dic_pad(dic_instance)
        print_dic_pad(dic_pad)
        #print(dic_pad)

        dic_stacker_stream = fill_in_dic_stacker_stream(dic_instance)
        print_dic_stacker_stream(dic_stacker_stream)
        #print(dic_stacker_stream)

        dic_load_point = fill_in_dic_load_point(dic_instance)
        print_dic_load_point(dic_load_point)
        #print(dic_load_point)

        dic_reclaimer = fill_in_dic_reclaimer(dic_instance)
        print_dic_reclaimer(dic_reclaimer)
        #print(dic_reclaimer)

        dic_time = fill_in_dic_time(dic_instance)
        print_dic_time(dic_time)
        #print(dic_time)


#print_infos_entity_by_label(dic_ship,0)


os.chdir("..") #INPUTRUN > GRANELTM


################## MAIN ALGORITHM GCA-ETA #################

OutPut = ALGORITHM1(dic_ship,dic_instance,dic_berth,dic_stockpile,dic_pad,dic_load_point, dic_stacker_stream, dic_reclaimer)
#Dic_Ship, Dic_Berth, Dic_Pad, etc...)


# listaaa = []
# for i in listaaa:
#     variavel = 0
#     variavel = 2*i
#
# print(variavel)
# print('end')

# dic_test = {
#     'teste': [[0], [2]]
#             }
#
# del(dic_test['teste'][0][0])
# print(dic_test['teste'])

# lista = [0,3,4,5,66]
#
# lista2 = lista[:-1]
# print(lista2)

# for i in [1,2,3]:
#     print(i)



# letter = ["W","A"]
# for i in letter:
#     if i == 'B':
#         print("letter is B")
#
#     elif i == "C":
#         print("letter is C")
#
#     elif i == "A":
#         print("letter is A")
#
#     else:
#         print("letter isn't A, B or C")

